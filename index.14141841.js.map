{"mappings":"AAAA","sources":["src/js/goit-autocheck-03.js"],"sourcesContent":["\"use strict\"\n\n// // autocheck-03-01/41\n// // Присвой переменной apartment объект описывающий квартиру со следующими характеристиками:\n// // - imgUrl - фотография, значение \"https://via.placeholder.com/640x480\";\n// // - descr - описание, значение \"Spacious apartment in the city center\";\n// // - rating - рейтинг, значение 4;\n// // - price - цена, значение 2153;\n// // - tags - метаинформация, массив [\"premium\", \"promoted\", \"top\"].\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n// };\n// console.log(apartment);\n\n// // autocheck-03-02/41\n// // Дополни объект квартиры свойством owner, значением которого будет объект с информацией о владельце. Добавь ему следующие свойства:\n// // - name - имя владельца, значение \"Henry\";\n// // - phone - телефон, значение \"982-126-1588\";\n// // - email - почта, значение \"henry.carter@aptmail.com\".\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n//     owner: {\n//         name: \"Henry\",\n//         phone: \"982-126-1588\",\n//         email: \"henry.carter@aptmail.com\",\n//     },\n// };\n// console.log(apartment);\n// console.log(apartment.owner);\n\n\n// // autocheck-03-03/41\n// // Дополни код присвоив объявленным переменным выражения обращения к соответствующим свойствам обьекта apartment.\n// // - aptRating - рейтинг;\n// // - aptDescr - описание;\n// // - aptPrice - цена;\n// // - aptTags - теги.\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n// };\n// const aptRating = apartment.rating;\n// const aptDescr = apartment.descr;\n// const aptPrice = apartment.price;\n// const aptTags = apartment.tags;\n// console.log(apartment);\n// console.log(aptRating);\n// console.log(aptDescr);\n// console.log(aptPrice);\n// console.log(aptTags);\n\n\n// // autocheck-03-04/41\n// // Дополни код присвоив объявленным переменным выражения обращения к соответствующим свойствам обьекта apartment.\n// // - ownerName - имя владельца;\n// // - ownerPhone - телефон владельца;\n// // - ownerEmail - почта владельца;\n// // - numberOfTags - количество элементов массива в свойстве tags;\n// // - firstTag - первый элемент массива в свойстве tags;\n// // - lastTag - последний элемент массива в свойстве tags.\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n//     owner: {\n//         name: \"Henry\",\n//         phone: \"982-126-1588\",\n//         email: \"henry.carter@aptmail.com\",\n//     },\n// };\n// const owner = apartment.owner;\n// const ownerName = apartment.owner.name;\n// const ownerPhone = apartment.owner.phone;\n// const ownerEmail = apartment.owner.email;\n// const numberOfTags = apartment.tags.length;\n// const firstTag = apartment.tags[0];\n// const lastTag = apartment.tags[apartment.tags.length-1];\n// console.log(ownerName);\n// console.log(ownerPhone);\n// console.log(ownerEmail);\n// console.log(numberOfTags);\n// console.log(firstTag);\n// console.log(lastTag);\n\n\n// // autocheck-03-05/41\n// // Дополни код присвоив объявленным переменным выражения обращения к соответствующим свойствам обьекта apartment используя синтаксис «квадратных скобок».\n// // - aptRating - рейтинг;\n// // - aptDescr - описание;\n// // - aptPrice - цена;\n// // - aptTags - теги.\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n// };\n// const aptRating = apartment[\"rating\"];\n// const aptDescr = apartment[\"descr\"];\n// const aptPrice = apartment[\"price\"];\n// const aptTags = apartment[\"tags\"];\n// console.log(aptRating);\n// console.log(aptDescr);\n// console.log(aptPrice);\n// console.log(aptTags);\n\n\n// // autocheck-03-06/41\n// // Дополни код обновив значения свойств объекта apartment:\n// // - цену в свойстве price на 5000;\n// // - рейтинг квартиры в свойстве rating на 4.7;\n// // - имя владельца во вложенном свойстве name на \"Henry Sibola\";\n// // - массив тегов в свойстве tags добавив в конец строку \"trusted\".\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n//     owner: {\n//         name: \"Henry\",\n//         phone: \"982-126-1588\",\n//         email: \"henry.carter@aptmail.com\",\n//     },\n// };\n// apartment.price = 5000;\n// apartment.rating = 4.7;\n// apartment.owner.name = \"Henry Sibola\";\n// apartment.tags.push(\"trusted\");\n// console.log(apartment);\n// console.log(apartment.price);\n// console.log(apartment.rating);\n// console.log(apartment.owner.name);\n// console.log(apartment.tags);\n\n\n// // autocheck-03-07/41\n// // Добавь объекту apartment несколько новых свойств:\n// // - area - площадь в квадратных метрах, число 60;\n// // - rooms - количество комнат, число 3;\n// // - location - местоположение квартиры, обьект со следующими вложенными свойствами;\n// // - country - страна, строка \"Jamaica\";\n// // - city - город, строка \"Kingston\".\n\n// const apartment = {\n//     imgUrl: \"https://via.placeholder.com/640x480\",\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n//     tags: [\"premium\", \"promoted\", \"top\"],\n//     owner: {\n//         name: \"Henry\",\n//         phone: \"982-126-1588\",\n//         email: \"henry.carter@aptmail.com\",\n//     },\n// };\n// apartment.area = 60;\n// apartment.rooms = 3;\n// apartment.location = {\n//     country: \"Jamaica\",\n//     city: \"Kingston\",\n// };\n// console.log(apartment);\n// console.log(apartment.area);\n// console.log(apartment.rooms);\n// console.log(apartment.location);\n\n\n// // autocheck-03-08/41\n// // Дополни код объявления объекта так, чтобы у него были свойства name, price, image и tags со значениями из переменных с аналогичными именами. Обязательно используй синтаксис коротких свойств.\n\n// const name = \"Repair Droid\";\n// const price = 2500;\n// const image = \"https://via.placeholder.com/640x480\";\n// const tags = [\"on sale\", \"trending\", \"best buy\"];\n\n// const product = {\n//     name,\n//     price,\n//     image,\n//     tags,\n// };\n// console.log(product);\n\n\n// // autocheck-03-09/41\n// // Дополни код объявления объекта credentials так, чтобы в результате у него были два свойства: email и password, имена которых хранятся в переменных emailInputName и passwordInputName.\n// // Значением свойства email должна быть строка \"henry.carter@aptmail.com\", а значением свойства password - строка \"jqueryismyjam\".\n\n// const emailInputName = \"email\";\n// const passwordInputName = \"password\";\n// const credentials = {\n//     [emailInputName]: \"henry.carter@aptmail.com\",\n//     [passwordInputName]: \"jqueryismyjam\",\n// };\n// console.log(credentials);\n\n\n// // autocheck-03-10/41\n// // Перебери объект apartment используя цикл for...in и запиши в массив keys все его ключи, а в массив values все значения его свойств.\n\n// const apartment = {\n//     descr: \"Spacious apartment in the city center\",\n//         rating: 4,\n//         price: 2153,\n// };\n\n// мой вариант №1\n// const keys = Object.keys(apartment);\n// const values = Object.values(apartment);\n\n// console.log(keys);\n// console.log(values);\n\n// // мой вариант №2\n// const keys = Object.keys(apartment);\n// const values = Object.values(apartment);\n\n// for (const key in keys) {\n//     console.log(keys);\n//     break;\n// };\n// for (const value in values) {\n//     console.log(values);\n//     break;\n// };\n\n// // еще вариант: выводится ключ(1)-значение(1), выводится ключ(2)-значение(2), выводится ключ(3)-значение(3)\n// const keys = [];\n// const values = [];\n// // Change code below this line\n// for (const key in apartment) {\n//     keys.push(key);\n//     values.push(apartment[key]);\n//     console.log(key);\n//     console.log(apartment[key]);\n// };\n\n// // решение в автопроверке\n// const apartment = {\n//    descr: \"Spacious apartment in the city center\",\n//    rating: 4,\n//    price: 2153,\n// };\n// const keys = ['descr', 'rating', 'price'];\n// const values = ['Spacious apartment in the city center', 4, 2153];\n// // Change code below this line\n// for (const key in apartment){\n//     console.log(key);\n//     console.log(apartment[key]);\n// }\n\n\n// // autocheck-03-11/41\n// // Выполни рефакторинг решения предыдущего задания добавив в цикл for...in проверку на собственное свойство.\n// // - Объявлена переменная advert.\n// // - Значение переменной advert это объект.\n// // - Объявлена переменная apartment.\n// // - Значение переменной apartment это объект.\n// // - Объявлена переменная keys.\n// // - Значение переменной keys это массив [\"descr\", \"rating\", \"price\"].\n// // - Объявлена переменная values.\n// // - Значение переменной values это массив [\"Spacious apartment in the city center\", 4, 2153].\n\n// const keys = [];\n// const values = [];\n// const advert = {\n//     service: \"apt\",\n// };\n// const apartment = Object.create(advert);\n// apartment.descr = \"Spacious apartment in the city center\";\n// apartment.rating = 4;\n// apartment.price = 2153;\n\n// for (const key in apartment) {\n\n//     if (apartment.hasOwnProperty(key)) {\n//         // keys.push(key);\n//         // values.push(apartment[key]);\n//         console.log(key);\n//         console.log(apartment[key]);\n//     };\n\n// }\n\n\n// // autocheck-03-12/41\n// // Напиши функцию countProps(object), которая считает и возвращает количество собственных свойств объекта в параметре object. Используй переменную propCount для хранения количества свойств объекта.\n\n// // решение в автопроверке\n// function countProps(object) {\n//     let propCount = 0;\n\n//     // 1. перебор ключей объекта object\n//     for (const key in object) {\n\n//     // 2. проверка наличия собственных свойств объекта\n//         if (object.hasOwnProperty(key)) {\n//             propCount += 1;\n//             console.log(propCount);\n//         };\n\n//     };\n\n//     return propCount;\n// };\n\n// // мой вариант\n// function countProps(object) {\n//     let propCount = 0;\n//     let keys = Object.keys(object);\n\n//     for (const key of keys) {\n//         propCount += 1;\n//         console.log(propCount);\n\n//     };\n\n//     return propCount;\n// }\n\n// countProps({});\n// countProps({ name: \"Mango\", age: 2 });\n// countProps({ mail: \"poly@mail.com\", isOnline: true, score: 500 }0);\n\n\n// // autocheck-03-13/41\n// // Перебери объект apartment используя метод Object.keys() и цикл for...of. Запиши в переменную keys массив ключей собственных свойств объекта apartment, и добавь в массив values все значения его свойств.\n// // - Объявлена переменная apartment.\n// // - Значение переменной apartment это объект.\n// // - Объявлена переменная keys.\n// // - Значение переменной keys это массив [\"descr\", \"rating\", \"price\"].\n// // - Значение переменной keys получено с помощью метода Object.keys().\n// // - Объявлена переменная values.\n// // - Значение переменной values это массив [\"Spacious apartment in the city center\", 4, 2153].\n// // - Значение переменной values получено с помощью цикла for...of.\n\n// const apartment = {\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n// };\n// const values = [];\n// const keys = Object.keys(apartment);\n//     for (const key of keys) {\n//     // Ключ\n//     // console.log(key);\n//     // Значение свойства\n//     // console.log(apartment[key]);\n        \n//         values.push(apartment[key]);\n//         console.log(values);\n//     };\n\n\n// // autocheck-03-14/41\n// // Выполни рефакторинг функции countProps(object) используя метод Object.keys() и, возможно, но необязательно, цикл for...of.\n// // - Объявлена функция countProps(object)\n// // - Вызов countProps({}) возвращает 0\n// // - Вызов countProps({ name: \"Mango\", age: 2 }) возвращает 2\n// // - Вызов countProps({ mail: \"poly@mail.com\", isOnline: true, score: 500 }) возвращает 3\n// // - Функция подсчитывает только собственные свойства объекта\n// // - Функция использует метод Object.keys() и, возможно, цикл for...of\n\n// // мой вариант, выведет массив из количества ключей\n// function countProps(object) {\n//     let propCount = 0;\n\n//     let keys = Object.keys(object);\n\n//     for (const key of keys) {\n//         propCount += 1;\n//         console.log(propCount);\n\n//     };\n//     console.log(keys);\n\n//     return propCount;\n// };\n\n// // еще вариант, сразу посчитает количество ключей\n// function countProps(object) {\n//     let propCount = 0;\n\n//     let keys = Object.keys(object).length;\n\n//     console.log(keys);\n\n//     return propCount;\n// }\n// countProps({});\n// countProps({ name: \"Mango\", age: 2 });\n// countProps({ mail: \"poly@mail.com\", isOnline: true, score: 500 });\n\n\n// // autocheck-03-15/41\n// // Запиши в переменную keys массив ключей собственных свойств объекта apartment, а в переменную values массив всех значений его свойств. Используй методы Object.keys() и Object.values().\n// // - Объявлена переменная apartment\n// // - Значение переменной apartment это объект\n// // - Объявлена переменная keys\n// // - Значение переменной keys это массив [\"descr\", \"rating\", \"price\"]\n// // - Объявлена переменная values\n// // - Значение переменной values это массив [\"Spacious apartment in the city center\", 4, 2153]\n// // - Для получения массива ключей объекта apartment используется Object.keys()\n// // - Для получения массива значений объекта apartment используется Object.values()\n\n// const apartment = {\n//     descr: \"Spacious apartment in the city center\",\n//     rating: 4,\n//     price: 2153,\n// };\n// const keys = Object.keys(apartment);\n// const values = Object.values(apartment);\n\n// console.log(keys);\n// console.log(values);\n\n// values.push(apartment[key]);\n\n// // autocheck-03-16/41\n// // Напиши функцию countTotalSalary(salaries) которая принимает объект зарплат, где имя свойства это имя сотрудника, а значение свойства это зарплата.Функция должна рассчитать общую сумму зарплат сотрудников и вернуть её.Используй переменную totalSalary для хранения общей суммы зарплаты.\n\n// function countTotalSalary(salaries) {\n//     let totalSalary = 0;\n\n//     // 1. массив значений\n//     const values = Object.values(salaries);\n//     // console.log(values);\n\n//     // 2. перебор\n//     for (const value of values) {\n    \n//     // 3. вычисление\n//         totalSalary += value;\n//     };\n\n//     console.log(totalSalary);\n\n//     return totalSalary;\n// };\n// countTotalSalary({});\n// countTotalSalary({ mango: 100, poly: 150, alfred: 80 });\n// countTotalSalary({ kiwi: 200, poly: 50, ajax: 150 });\n\n\n// // autocheck-03-17/41\n// // Перебери массив объектов colors используя цикл for...of. Добавь в массив hexColors значения свойств hex, а в массив rgbColors значения свойств rgb из всех объектов массива colors.\n\n// const colors = [\n//     { hex: \"#f44336\", rgb: \"244,67,54\" },\n//     { hex: \"#2196f3\", rgb: \"33,150,243\" },\n//     { hex: \"#4caf50\", rgb: \"76,175,80\" },\n//     { hex: \"#ffeb3b\", rgb: \"255,235,59\" },\n// ];\n\n// const hexColors = [];\n// const rgbColors = [];\n\n// for ( let color of colors) {\n//     hexColors.push(color.hex);\n//     rgbColors.push(color.rgb);\n//     console.log(hexColors);\n//     console.log(rgbColors);\n// };\n\n\n// // autocheck-03-18/41\n// // Напиши функцию getProductPrice(productName) которая принимает один параметр productName - название продукта.Функция ищет объект продукта с таким именем(свойство name) в массиве products и возвращает его цену(свойство price).Если продукт с таким названием не найден, функция должна возвращать null.\n\n// const products = [\n//     { name: \"Radar\", price: 1300, quantity: 4 },\n//     { name: \"Scanner\", price: 2700, quantity: 3 },\n//     { name: \"Droid\", price: 400, quantity: 7 },\n//     { name: \"Grip\", price: 1200, quantity: 9 },\n// ];\n\n// function getProductPrice(productName) {\n//     for (let product of products) {\n        \n//         if (product.name === productName) {\n//             console.log(product.price);\n//             return product.price;\n//         };\n//     };\n//         return null;\n// };\n// getProductPrice(\"Radar\");\n// getProductPrice(\"Grip\");\n// getProductPrice(\"Scanner\");\n// getProductPrice(\"Droid\");\n// getProductPrice(\"Engine\");\n\n\n// // autocheck-03-19/41\n// // Напиши функцию getAllPropValues(propName) которая принимает один параметр propName - имя (ключ) свойства. Функция должна вернуть массив всех значений свойства с таким именем из каждого объекта в массиве products. Если в объектах нет свойства с таким именем, функция должна вернуть пустой массив.\n\n// const products = [\n//     { name: \"Radar\", price: 1300, quantity: 4 },\n//     { name: \"Scanner\", price: 2700, quantity: 3 },\n//     { name: \"Droid\", price: 400, quantity: 7 },\n//     { name: \"Grip\", price: 1200, quantity: 9 },\n// ];\n\n\n// // решение в автопроверке\n// function getProductPrice(propName) {\n\n//     // 1. объявлен массив без значений\n//     const propValue = [];\n\n//     // 2. перебор массива products\n//     for (const product of products) {\n\n//     // 3. проверка наличия собственных значений\n//         if (product.hasOwnProperty(propName)) {\n\n//     // 4. наполняем массив этими значениями\n//                 propValue.push(product[propName]);\n//                 console.log(propValue);\n//         };\n\n//     };\n//         return propValue;\n// };\n\n// // еще вариант решения\n// // function getProductPrice(propName) {\n    \n// //     let result = [];\n// //     for (const product of products) {\n// //         if (propName === 'name') {\n// //             result.push(product.name);\n// //             console.log(result);\n// //         };\n// //         if (propName === 'quantity') {\n// //             result.push(product.quantity);\n// //             console.log(result);\n// //         };\n// //         if (propName === 'price') {\n// //             result.push(product.price);\n// //             console.log(result);\n// //         };\n// //     };\n// //     return result;\n// // };\n\n// getProductPrice(\"name\");\n// getProductPrice(\"quantity\");\n// getProductPrice(\"price\");\n// getProductPrice(\"category\");\n\n\n\n// // autocheck-03-20/41\n// // Напиши функцию calculateTotalPrice(productName) которая принимает один параметр productName - название товара. Функция должна вернуть общую стоимость (цена * количество) товара с таким именем из массива products.\n\n// const products = [\n//     { name: \"Radar\", price: 1300, quantity: 4 },\n//     { name: \"Scanner\", price: 2700, quantity: 3 },\n//     { name: \"Droid\", price: 400, quantity: 7 },\n//     { name: \"Grip\", price: 1200, quantity: 9 },\n// ];\n\n// function calculateTotalPrice(productName) {\n\n//     for (let product of products) {\n//         if (product.name === productName) {\n//             console.log(product.price * product.quantity);\n//             return product.price * product.quantity;\n//         };\n//     };\n\n//     console.log(0);\n//     return 0;\n// };\n// calculateTotalPrice(\"Blaster\");\n// calculateTotalPrice(\"Radar\");\n// calculateTotalPrice(\"Droid\");\n// calculateTotalPrice(\"Grip\");\n// calculateTotalPrice(\"Scanner\");\n\n\n// // autocheck-03-21/41\n// // Пришел трёхдневный прогноз максимальных температур и мы считаем среднюю температуру за три дня (meanTemperature). Замени объявления переменных yesterday, today и tomorrow одной операцией деструктуризации свойств объекта highTemperatures.\n\n// const highTemperatures = {\n//     yesterday: 28,\n//     today: 26,\n//     tomorrow: 33,\n// };\n\n// const { yesterday, today, tomorrow } = highTemperatures;\n// console.log(highTemperatures);\n\n// const meanTemperature = (yesterday + today + tomorrow) / 3;\n// console.log(meanTemperature);\n\n\n// // autocheck-03-22/41\n// // В прогнозе максимальных температур также может быть необязательное свойство icon - иконка погоды. Замени объявления переменных yesterday, today, tomorrow и icon одной операцией деструктуризации свойств объекта highTemperatures. Задай значение по умолчанию для icon - строку \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\".\n\n// const highTemperatures = {\n//     yesterday: 28,\n//     today: 26,\n//     tomorrow: 33,\n// };\n\n// const { yesterday,\n//     today,\n//     tomorrow,\n//     icon = \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\",\n// } = highTemperatures;\n// console.log(highTemperatures);              // не выводит значение icon\n// console.log(icon);                          // выводит значение icon\n\n// const meanTemperature = (yesterday + today + tomorrow) / 3;\n// console.log(meanTemperature);\n\n\n// // autocheck-03-23/41\n// // Замени объявления переменных highYesterday, highToday, highTomorrow и highIcon одной операцией деструктуризации свойств объекта highTemperatures. Задай значение по умолчанию для highIcon - строку \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\".\n\n// const highTemperatures = {\n//     yesterday: 28,\n//     today: 26,\n//     tomorrow: 33,\n// };\n\n// const {\n//     yesterday: highYesterday,\n//     today: highToday,\n//     tomorrow: highTomorrow,\n//     icon: highIcon = \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\",\n// } = highTemperatures;\n// console.log(highTemperatures);\n\n// const meanTemperature = (highYesterday + highToday + highTomorrow) / 3;\n\n\n// // autocheck-03-24/41\n// // Выполни рефакторинг цикла for...of так, чтобы в нём использовалась деструктуризация объекта..\n\n// const colors = [\n//     { hex: \"#f44336\", rgb: \"244,67,54\" },\n//     { hex: \"#2196f3\", rgb: \"33,150,243\" },\n//     { hex: \"#4caf50\", rgb: \"76,175,80\" },\n//     { hex: \"#ffeb3b\", rgb: \"255,235,59\" },\n// ];\n\n// const hexColors = [];\n// const rgbColors = [];\n// // Change code below this line\n\n// for (const {hex, rgb} of colors) {\n//     hexColors.push(hex);\n//     rgbColors.push(rgb);\n//     console.log(hexColors);\n//     console.log(rgbColors);\n// };\n\n\n// // autocheck-03-25/41\n// // Мы получили прогноз погоды на два дня, с минимальными и максимальными температурами, а также необязательными иконками. Замени объявления всех переменных одной операцией деструктуризации свойств объекта forecast. Задай значение по умолчанию для иконок, переменных todayIcon и tomorrowIcon - строку \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\".\n\n// const forecast = {\n//     today: {\n//         low: 28,\n//         high: 32,\n//         icon: \"https://www.flaticon.com/svg/static/icons/svg/861/861059.svg\",\n//     },\n//     tomorrow: {\n//         low: 27,\n//         high: 31,\n//     },\n// };\n\n// const {\n//     today: {\n//         low: lowToday,\n//         high: highToday,\n//         icon: todayIcon = \"https://www.flaticon.com/svg/static/icons/svg/861/861059.svg\" },\n//     tomorrow: {\n//         low: lowTomorrow,\n//         high: highTomorrow,\n//         icon: tomorrowIcon = \"https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg\"}\n// } = forecast;\n// console.log(lowToday);\n// console.log(highTomorrow);\n// console.log(tomorrowIcon);\n\n\n// // autocheck-03-26/41\n// // Функция calculateMeanTemperature(forecast) принимает один параметр forecast - объект температур на два дня следующего формата.\n// // {\n// //   today: { low: 10, high: 20 },\n// //   tomorrow: { low: 20, high: 30 }\n// // }\n// // Замени объявления переменных todayLow, todayHigh, tomorrowLow и tomorrowHigh одной операцией деструктуризации свойств объекта forecast.\n\n// function calculateMeanTemperature(forecast) {\n// const {\n//     today: {\n//         low: todayLow,\n//         high: todayHigh\n//         },\n//     tomorrow: {\n//         low: tomorrowLow,\n//         high: tomorrowHigh,\n//         }\n//     } = forecast;\n\n//     console.log((todayLow + todayHigh + tomorrowLow + tomorrowHigh) / 4);\n\n//     return (todayLow + todayHigh + tomorrowLow + tomorrowHigh) / 4;\n// }\n// calculateMeanTemperature({ today: {low: 28, high: 32}, tomorrow: {low: 25, high: 29} });\n// calculateMeanTemperature({ today: {low: 37, high: 40}, tomorrow: {low: 33, high: 38} });\n\n\n// // autocheck-03-27/41\n// // В переменной scores хранится массив результатов тестирования. Используя распыление и методы Math.max() и Math.min() дополни код так, чтобы в переменной bestScore был самый высокий балл, а в worstScore самый низкий.\n\n// const scores = [89, 64, 42, 17, 93, 51, 26];\n\n// const bestScore = Math.max(...scores);\n// const worstScore = Math.min(...scores);\n// console.log(bestScore);                         //93\n// console.log(worstScore);                        //17\n\n\n// // autocheck-03-28/41\n// // В переменных firstGroupScores, secondGroupScores и thirdGroupScores хранятся результаты тестирования отдельных групп. Используя распыление дополни код так, чтобы:\n// // - В переменной allScores хранился массив всех результатов от первой до третьей группы.\n// // - В переменной bestScore был самый высокий общий балл.\n// // - В переменной worstScore был самый низкий общий балл.\n\n// const firstGroupScores = [64, 42, 93];\n// const secondGroupScores = [89, 14, 51, 26];\n// const thirdGroupScores = [29, 47, 18, 97, 81];\n\n// const allScores = [...firstGroupScores, ...secondGroupScores, ...thirdGroupScores];\n// const bestScore = Math.max(...allScores);\n// const worstScore = Math.min(...allScores);\n// console.log(bestScore);                         //97\n// console.log(worstScore);                        //14\n\n\n// // autocheck-03-29/41\n// // В конструкторе можно создавать новые тесты, для которых есть настройки по умолчанию которые хранятся в переменной defaultSettings. Во время создания теста, все или часть настроек можно переопределить, они хранятся в переменной overrideSettings.\n// // Для того чтобы получить финальные настройки теста, необходимо взять настройки по умолчанию и поверх них применить переопределённые настройки.Дополни код так, чтобы в переменной finalSettings получился объект финальных настроек теста.\n\n// const defaultSettings = {\n//     theme: \"light\",\n//     public: true,\n//     withPassword: false,\n//     minNumberOfQuestions: 10,\n//     timePerQuestion: 60,\n// };\n// const overrideSettings = {\n//     public: false,\n//     withPassword: true,\n//     timePerQuestion: 30,\n// };\n\n// const finalSettings = { ...defaultSettings, ...overrideSettings };\n// console.log(finalSettings);                         //{theme: 'light', public: false, withPassword: true, minNumberOfQuestions: 10, timePerQuestion: 30}\n\n\n// // autocheck-03-30/41\n// // Напиши функцию makeTask(data) которая принимает один параметр data - объект со следующими свойствами.\n// // - text - текст задачи.\n// // - category - категория задачи.\n// // - priority - приоритет задачи.\n// // Функция должна составить и вернуть новый объект задачи, не изменяя напрямую параметр data. В новом объекте должно быть свойство completed, значение которого хранится в одноимённой локальной переменной.\n// // В параметре data гарантированно будет только свойство text, а остальные два, category и priority, могут отсутствовать. Тогда, в новом объекте задачи, в свойствах category и priority должны быть значения по умолчанию, хранящиеся в одноимённых локальных переменных.\n\n// function makeTask(data) {\n//     const completed = false;\n//     const category = \"General\";\n//     const priority = \"Normal\";\n//     // Добавлен arr, чтобы увидеть результат\n//     let arr = { ...{ category, priority, completed }, ...data }\n//     console.log(arr);\n//     // Само решение\n//     return { ...{ category, priority, completed }, ...data }\n// }\n// makeTask({ });\n// makeTask({ category: \"Homemade\", priority: \"Low\", text: \"Take out the trash\" });\n// makeTask({ category: \"Finance\", text: \"Take interest\" });\n// makeTask({ priority: \"Low\", text: \"Choose shampoo\" });\n// makeTask({ text: \"Buy bread\" });\n\n\n// // autocheck-03-31/41\n// // Используя операцию rest дополни код функции add() так, чтобы она принимала любое количество аргументов, считала и возвращала их сумму.\n// function add(...args) {\n//     let total = 0;\n//     for (let arg of args) {\n//         total += arg;\n//     }\n//     console.log(total);\n//     return total;\n// }\n// add(15, 27);\n// add(12, 4, 11, 48);\n// add(32, 6, 13, 19, 8);\n// add(74, 11, 62, 46, 12, 36);\n\n\n// // autocheck-03-32/41\n// // Функция addOverNum() считает сумму всех аргументов. Измени параметры и тело функции addOverNum() так, чтобы она считала сумму только тех аргументов, которые больше чем заданное число. Это число должно быть первым параметром функции.\n// function addOverNum(firstArg, ...args) {\n//     let total = 0;\n\n//     for (const arg of args) {\n\n//         if (arg > firstArg) {\n//                 total += arg;\n//         }\n//     }\n//     console.log(total);\n//     return total;\n// }\n// addOverNum(50, 15, 27)                          // 0\n// addOverNum(10, 12, 4, 11, 48, 10, 8)            // 71\n// addOverNum(15, 32, 6, 13, 19, 8)                // 51\n// addOverNum(20, 74, 11, 62, 46, 12, 36)          // 218\n\n\n// // autocheck-03-33/41\n// // Функция findMatches() принимает произвольное количество аргументов. Первым аргументом всегда будет массив чисел, а остальные аргументы будут просто числами.\n// // Дополни код функции так, чтобы она возвращала новый массив matches, в котором будут только те аргументы, начиная со второго, которые есть в массиве первого аргумента.\n// // Например, findMatches([1, 2, 3, 4, 5], 1, 8, 2, 7) должна вернуть массив [1, 2], потому что только они есть в массиве первого аргумента.\n\n// function findMatches(arr1, ...arr2) {\n//     const matches = []; // Don't change this line\n\n    // for (let number of arr2) {\n    //     if (arr1.includes(number)) {\n    //         matches.push(number);\n    //     }\n    // }\n    // console.log(matches);\n    // return matches;\n// }\n// findMatches([1, 2, 3, 4, 5], 1, 8, 2, 7);\n// findMatches([4, 89, 17, 36, 2], 8, 17, 89, 27, 2);\n// findMatches([10, 24, 41, 6, 9, 19], 24, 11, 9, 23, 41);\n// findMatches([63, 11, 8, 29], 4, 7, 16);\n\n\n// // autocheck-03-34/41\n// // Добавь объекту bookShelf ещё два метода, которые пока что будут возвращать просто строки по аналогии с getBooks() и addBook(bookName).\n// // Метод removeBook(bookName) будет удалять книгу по имени. Возвращает строку \"Deleting book <имя книги>\", где <имя книги> это значение параметра bookName.\n// // Метод updateBook(oldName, newName) будет обновлять название книги на новое. Возвращает строку \"Updating book <старое имя> to <новое имя>\", где <старое имя> и <новое имя>это значения параметров oldName и newName соотвественно.\n\n// const bookShelf = {\n//   // Change code below this line\n//     books: [\"The last kingdom\", \"The guardian of dreams\"],\n//     getBooks() {\n//         console.log(\"Returning all books\");\n//         return \"Returning all books\";\n//     },\n//     addBook(bookName) {\n//         console.log(`Adding book ${bookName}`);\n//         return `Adding book ${bookName}`;\n//     },\n//     removeBook(bookName) {\n//         console.log(`Deleting book ${bookName}`);\n//         return `Deleting book ${bookName}`;\n//     },\n//     updateBook(oldName, newName) {\n//         console.log(`Updating book ${oldName} to ${newName}`);\n//         return `Updating book ${oldName} to ${newName}`;\n//     },\n//   // Change code above this line\n// };\n// bookShelf.getBooks();\n// bookShelf.addBook(\"Haze\");\n// bookShelf.removeBook(\"Red sunset\");\n// bookShelf.updateBook(\"Sands of dune\", \"Dune\");\n\n\n// // autocheck-03-35/41\n// // Дополни метод updateBook(oldName, newName) так, чтобы он изменял название книги с oldName на newName в свойстве books. Используй indexOf() для того, чтобы найти нужный элемент массива, и splice() для того чтобы заменить этот элемент\n// const bookShelf = {\n//     books: [\"The last kingdom\", \"Haze\", \"The guardian of dreams\"],\n//     updateBook(oldName, newName) {\n//     // переменная, которая находит индекс элемента для замены\n//         const bookIndex = this.books.indexOf(oldName);\n//         console.log(bookIndex);\n//     // метод, который отрабатывает замену\n//         this.books.splice(bookIndex, 1, newName);\n//         console.log(this.books);\n//         return this.books;\n//     },\n// };\n// bookShelf.updateBook(\"Haze\", \"Dungeon chronicles\");\n// bookShelf.updateBook(\"The last kingdom\", \"Dune\");\n\n\n// // autocheck-03-36/41\n// // К нам обратилась владелица лавки зелий «У старой жабы» и заказала программу для ведения инвентаря - добавления, удаления, поиска и обновления зелий. Добавь объекту atTheOldToad свойство potions, значением которого сделай пустой массив.\n\n// const atTheOldToad = {\n//     potions : []\n// };\n// console.log(atTheOldToad.potions);\n\n\n// // autocheck-03-37/41\n// // Добавь объекту atTheOldToad метод getPotions(), который просто возвращает значение свойства potions.\n\n// const atTheOldToad = {\n//     potions: [\"Speed potion\", \"Dragon breath\", \"Stone skin\"],\n//     // решение в автопроверке\n//     getPotions(){\n//         console.log(this.potions);\n//         return this.potions;\n//     },\n// };\n\n\n// // autocheck-03-38/41\n// // Дополни метод addPotion(potionName) так, чтобы он добавлял зелье potionName в конец массива зелий в свойстве potions.\n\n// const atTheOldToad = {\n//     potions: [\"Speed potion\", \"Dragon breath\", \"Stone skin\"],\n//     addPotion(potionName) {\n\n//         if (this.potions.includes(potionName)) {\n//             return this.addPotion\n//         }\n\n//         this.potions.push(potionName);\n//         console.log(this.potions);\n//     },\n// };\n// atTheOldToad.addPotion(\"Invisibility\");\n// atTheOldToad.addPotion(\"Power potion\");\n\n\n// // autocheck-03-39/41\n// Дополни метод removePotion(potionName) так, чтобы он удалял зелье potionName из массива зелий в свойстве potions.\n\n// const atTheOldToad = {\n//     potions: [\"Speed potion\", \"Dragon breath\", \"Stone skin\"],\n//     removePotion(potionName) {\n\n//         if (this.potions.includes(potionName)) {                    // проверка наличия этого значения\n//             const potionIndex = this.potions.indexOf(potionName);   // определения индекса в массиве\n//             this.potions.splice(potionIndex, 1);                    // удаление из массива\n//             console.log(this.potions);\n//             return this.addPotion;\n//         }\n\n//         console.log(this.potions);\n//     },\n// };\n// atTheOldToad.removePotion(\"Dragon breath\");\n// atTheOldToad.removePotion(\"Speed potion\");\n\n\n// // autocheck-03-40/41\n// // Дополни метод updatePotionName(oldName, newName) так, чтобы он обновлял название зелья с oldName на newName, в массиве зелий в свойстве potions.\n// const atTheOldToad = {\n//     potions: [\"Speed potion\", \"Dragon breath\", \"Stone skin\"],\n//     updatePotionName(oldName, newName) {\n//         const potionIndex = this.potions.indexOf(oldName);\n//         this.potions.splice(potionIndex, 1, newName);\n//         console.log(this.potions);\n//         return this.addPotion;\n\n//     },\n// }\n// atTheOldToad.updatePotionName(\"Dragon breath\", \"Polymorth\");\n// atTheOldToad.updatePotionName(\"Stone skin\", \"Invisibility\");\n\n\n// // autocheck-03-41/41\n// Заказчица хочет чтобы каждое зелье было представлено не только именем, но и ценой, а в будущем может быть и другими характеристиками. Поэтому теперь в свойстве potions будет храниться массив объектов со следующими свойствами.\n// { name: \"Dragon breath\", price: 700 }\n// Выполни рефакторинг методов объекта atTheOldToad так, чтобы они работали не с массивом строк, а с массивом объектов.\n// - getPotions() - метод для получения всех зелий. Возвращает значение свойства potions.\n// - addPotion(newPotion) - добавляет зелье newPotion (уже объект) в массив в свойстве potions, но только если такого зелья еще нет в инвентаре. В противном случае возвращается строка.\n// - removePotion(potionName) - удаляет объект зелья с именем potionName из массива в свойстве potions.\n// - updatePotionName(oldName, newName) - обновляет свойство name объекта-зелья с названием oldName на newName в массиве potions.\n\n// const atTheOldToad = {\n//     potions: [\n//         { name: \"Speed potion\", price: 460 },\n//         { name: \"Dragon breath\", price: 780 },\n//         { name: \"Stone skin\", price: 520 },\n//     ],\n\n//     getPotions() {\n//         console.log(this.potions);                  // выводит массив с 3 объектами\n//         return this.potions;\n//     },\n\n//     addPotion(newPotion) {\n//         // исходный вариант\n//         // if (this.potions.includes(newPotion)) {\n//         //     return `Error! Potion ${newPotion} is already in your inventory!`;\n//         // };\n//         // this.potions.push(newPotion);\n\n//         // рефакторинг\n//         for (const item of this.potions) {\n//             if (item.name === newPotion.name) {\n//                 console.log(`Error! Potion ${newPotion.name} is already in your inventory!`);   // выводит сообщение о наличии  этого параметра\n//                 return `Error! Potion ${newPotion.name} is already in your inventory!`;\n//             };\n//         };\n//         const newProduct = {\n//             ...newPotion,\n//         }; \n//         console.log(newPotion);                     // выводит новые объекты {name: X, price: Y }\n//         this.potions.push(newPotion);\n//     },\n\n//     removePotion(potionName) {\n//         // // исходный вариант\n//         // const potionIndex = this.potions.indexOf(potionName);\n//         // if (potionIndex === -1) {\n//         //     return `Potion ${potionName} is not in inventory!`;\n//         // };\n\n//         // рефакторинг\n//         for (let i = 0; i < this.potions.length; i += 1) {\n//             const potion = this.potions[i];\n//             if (potionName === potion.name) {\n//                 this.potions.splice(i, 1);\n//                 console.log(`Potion ${potionName} is not in inventory!`);       // выводит сообщение, что этого параметра нет (после удаления)\n//                 return `Potion ${potionName} is not in inventory!`;\n//             }            \n//         }        \n//     },\n\n//     updatePotionName(oldName, newName) {\n//     //     // // исходный вариант\n//             // const potionIndex = this.potions.indexOf(oldName);\n//             // if (potionIndex === -1) {\n//             //     return `Potion ${oldName} is not in inventory!`;\n//             // }\n//             // this.potions.splice(potionIndex, 1, newName);\n\n//     //     // рефакторинг\n//         for (let i = 0; i < this.potions.length; i += 1) {\n//             const potion = this.potions[i];\n            \n//             if (oldName === potion.name) {\n//                 potion.name = newName;\n//             }\n//         }\n//         console.log(this.potions);                            // выводит массив с 3 объектами, но с замененными данными\n//     },\n\n// };\n// atTheOldToad.getPotions();\n// atTheOldToad.addPotion({ name: \"Invisibility\", price: 620 });\n// atTheOldToad.addPotion({ name: \"Dragon breath\", price: 700 });\n// atTheOldToad.addPotion({ name: \"Dragon breath\", price: 700 });\n// atTheOldToad.addPotion({ name: \"Stone skin\", price: 240 });\n// atTheOldToad.removePotion(\"Dragon breath\");\n// atTheOldToad.removePotion(\"Speed potion\");\n// atTheOldToad.updatePotionName(\"Dragon breath\", \"Polymorth\");\n// atTheOldToad.updatePotionName(\"Stone skin\", \"Invulnerability potion\");"],"names":[],"version":3,"file":"index.14141841.js.map"}