{"mappings":"AAAA","sources":["src/js/goit-autocheck-05.js"],"sourcesContent":["\"use strict\";\n\n\n// // autocheck-05-1/20\n// // Выполни рефакторинг методов объекта pizzaPalace, расставив отсутствующие this в местах обращения к свойствам и методам объекта.\n\n// const pizzaPalace = {\n//     pizzas: [\"Supercheese\", \"Smoked\", \"Four meats\"],\n\n//     checkPizza(pizzaName) {\n//         return this.pizzas.includes(pizzaName);\n//         },\n  \n//     order(pizzaName) {\n//         const isPizzaAvailable = this.checkPizza(pizzaName);\n\n//         if (!isPizzaAvailable) {\n//             return `Sorry, there is no pizza named «${pizzaName}»`;\n//         }\n\n//         return `Order accepted, preparing «${pizzaName}» pizza`;\n//     },\n// };\n// console.log(pizzaPalace.checkPizza(\"Smoked\"));          // true\n// console.log(pizzaPalace.order(\"Smoked\"));               // Order accepted, preparing «Smoked» pizza\n// console.log(pizzaPalace.order(\"4Cheese\"));              // Sorry, there is no pizza named «4Cheese»\n\n\n// // autocheck-05-2/20\n// // Перед увольнением разработчик сломал исходный код управления аккаунтами пользователей нашего сервиса доставки еды. Выполни рефакторинг методов объекта customer, расставив отсутствующие this при обращении к свойствам объекта.\n// // После объявления объекта мы добавили вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// const customer = {\n//     username: \"Mango\",\n//     balance: 24000,\n//     discount: 0.1,\n//     orders: [\"Burger\", \"Pizza\", \"Salad\"],\n\n//     getBalance() {\n//         return this.balance;\n//     },\n//     getDiscount() {\n//         return this.discount;\n//     },\n//     setDiscount(value) {\n//         this.discount = value;\n//     },\n//     getOrders() {\n//         return this.orders;\n//     },\n//     addOrder(cost, order) {\n//         this.balance -= cost - cost * this.discount;\n//         this.orders.push(order);\n//     },\n\n// };\n\n// customer.setDiscount(0.15);\n// console.log(customer.getDiscount()); // 0.15\n// customer.addOrder(5000, \"Steak\");\n// console.log(customer.getBalance()); // 19750\n// console.log(customer.getOrders()); // [\"Burger\", \"Pizza\", \"Salad\", \"Steak\"]\n\n\n// // autocheck-05-3/20\n// // Тестировщики нашли баги в коде сервиса хранения истории заказов еды. Тебе необходимо исправить их, правильно расставив this в методах объекта historyService, чтобы методы начали работать правильно.\n\n// const historyService = {\n//     orders: [\n//         { email: \"jacob@hotmail.com\", dish: \"Burrito\" },\n//         { email: \"solomon@topmail.net\", dish: \"Burger\" },\n//         { email: \"artemis@coldmail.net\", dish: \"Pizza\" },\n//         { email: \"solomon@topmail.net\", dish: \"Apple pie\" },\n//         { email: \"jacob@hotmail.com\", dish: \"Taco\" },\n//     ],\n//     // Change code below this line\n//     getOrdersLog() {\n//         return this.orders\n//             .map(order => `email: ${order.email} dish: ${order.dish}`)\n//             .join(\" - \");\n//     },\n//     getEmails() {\n//         const emails = this.orders.map(order => order.email);\n//         const uniqueEmails = new Set(emails);\n//         return [...uniqueEmails];\n//     },\n//     getOrdersByEmail(email) {\n//         return this.orders.filter(order => order.email === email);\n//     },\n//     // Change code above this line\n// };\n\n// // строка с перечислением данных всех заказов из свойства orders\n// console.log(historyService.getOrdersLog());\n// // массив всех уникальных почтовых адресов из свойства orders\n// console.log(historyService.getEmails());\n// // массив из почтового адреса и блюда, отфильтрованный по почтовому адресу\n// console.log(historyService.getOrdersByEmail(\"solomon@topmail.net\"));\n// console.log(historyService.getOrdersByEmail(\"artemis@coldmail.net\"));\n\n\n// // autocheck-05-4/20\n// // Измени код так, чтобы объект parent стал прототипом для объекта в переменной сhild.\n\n// const parent = {\n//     name: \"Stacey\",\n//     surname: \"Moore\",\n//     age: 54,\n//     heritage: \"Irish\",\n// };\n\n// const child = Object.create(parent);\n// child.name = \"Jason\";\n// child.age = 27;\n\n// console.log(child);\n// console.log(child.age);\n// // свойство parent.heritage выведет только при выключенном \"use strict\"\n// console.log(child.heritage);\n\n\n// // autocheck-05-5/20\n// // Измени код, построив цепочку прототипов так, чтобы объект ancestor был прототипом для parent, а тот в свою очередь был прототипом для child.\n\n// const ancestor = {\n//     name: \"Paul\",\n//     age: 83,\n//     surname: \"Dawson\",\n//     heritage: \"Irish\",\n// };\n\n// const parent = Object.create(ancestor);\n// parent.name = \"Stacey\";\n// parent.surname = \"Moore\";\n// parent.age = 54;\n\n// const child = Object.create(parent);\n// child.name = \"Jason\";\n// child.age = 27;\n\n// console.log(child);\n// // {name: 'Jason', age: 27}\n// // age: 27\n// // name: \"Jason\"\n    \n// // [[Prototype]]: Object\n// // age: 54\n// // name: \"Stacey\"\n// // surname: \"Moore\"\n    \n// // [[Prototype]]:\n// // Objectage: 83\n// // heritage: \"Irish\"\n// // name: \"Paul\"\n// // surname: \"Dawson\"\n    \n// // [[Prototype]]:\n// // Object\n// // constructor: ƒ Object()\n// // hasOwnProperty: ƒ hasOwnProperty()\n// // isPrototypeOf: ƒ isPrototypeOf()\n// // propertyIsEnumerable: ƒ propertyIsEnumerable()\n// // toLocaleString: ƒ toLocaleString()\n// // toString: ƒ toString()\n// // valueOf: ƒ valueOf()\n// // __defineGetter__: ƒ __defineGetter__()\n// // __defineSetter__: ƒ __defineSetter__()\n// // __lookupGetter__: ƒ __lookupGetter__()\n// // __lookupSetter__: ƒ __lookupSetter__()\n// // __proto__: (…)\n// // get __proto__: ƒ __proto__()\n// // set __proto__: ƒ __proto__()\n\n// console.log(child.age);                                  // 27\n// // свойство parent.heritage выведет только при выключенном \"use strict\"\n// console.log(child.heritage);                            // Irish\n// console.log(child.hasOwnProperty(\"heritage\"));          // false\n\n\n// // autocheck-05-6/20\n// // Используя ключевое слово class, объяви класс Car с пустым телом.\n\n// class Car { };\n// console.log(Car);                       // class Car { }\n\n\n// // autocheck-05-7/20\n// // Добавь классу Car метод constructor который принимает три параметра:\n// // - brand - марка автомобиля.\n// // - model - модель автомобиля.\n// // - price - цена автомобиля.\n// // Класс Car должен создавать объект с одноимёнными свойствами brand, model и price, значениями которых должны быть переданные аргументы во время её вызова с оператором new.\n\n// class Car {\n\n//     constructor(brand, model, price) {\n//         this.brand = brand;\n//         this.model = model;\n//         this.price = price;\n//     }\n\n// }\n// const car1 = new Car(\"Audi\", \"Q3\", 36000);\n// const car2 = new Car(\"BMW\", \"X5\", 58900);\n// const car3 = new Car(\"Nissan\", \"Murano\", 31700);\n\n// console.log(car1);              // Car {brand: 'Audi', model: 'Q3', price: 36000}\n// console.log(car2);\n// console.log(car3);\n\n\n// // autocheck-05-8/20\n// // Выполни рефакторинг класса Car так, чтобы он принимал один параметр - объект со свойсвами brand, model и price. Деструктуризируй объект в сигнатуре (подписи) конструктора.\n\n// class Car {\n\n//     constructor({brand, model, price}) {\n//         this.brand = brand;\n//         this.model = model;\n//         this.price = price;\n//     }\n\n// }\n// const car1 = new Car({\n//     brand: \"Audi\",\n//     model: \"Q3\",\n//     price: 36000\n// });\n// const car2 = new Car({\n//     brand: \"BMW\",\n//     model: \"X5\",\n//     price: 58900\n// });\n// const car3 = new Car({\n//     brand: \"Nissan\",\n//     model: \"Murano\",\n//     price: 31700\n// });\n\n// console.log(car1);\n// console.log(car2);\n// console.log(car3);\n\n\n// // autocheck-05-9/20\n// // Добавь классу Car два метода.\n// // - getPrice() - возвращает значение свойства price из объекта который его будет вызывать.\n// // - changePrice(newPrice) - обновляет значение свойства price у объекта который его будет вызывать на newPrice.\n\n// class Car {\n\n//     constructor({brand, model, price}) {\n//         this.brand = brand;\n//         this.model = model;\n//         this.price = price;\n//     }\n\n//     getPrice() {\n//         return this.price;\n//     }\n\n//     changePrice(newPrice) {\n//         return this.price = newPrice;\n//     }\n// }\n// const car1 = new Car({\n//     brand: \"Audi\",\n//     model: \"Q3\",\n//     price: 36000\n// });\n// const car2 = new Car({\n//     brand: \"BMW\",\n//     model: \"X5\",\n//     price: 58900\n// });\n// const car3 = new Car({\n//     brand: \"Nissan\",\n//     model: \"Murano\",\n//     price: 31700\n// });\n\n// console.log(car1);                      // 36000\n// console.log(car1.getPrice());           // 36000\n// console.log(car1.changePrice(35000));   // 35000\n// // после вызова метода параметр price в массиве перезаписывается\n// console.log(car1.changePrice(250));     // 250\n// console.log(car1);                      // Car {brand: 'Audi', model: 'Q3', price: 250}\n\n\n// // autocheck-05-10/20\n// // Напиши класс Storage, который будет создавать объекты для управления складом товаров. Класс ожидает только один аргумент - начальный массив товаров, который записывается на создаваемый объект в свойство items.\n// // Объяви следующие методы класса:\n// // - getItems() - возвращает массив текущих товаров в свойстве items объекта который вызывает этот метод.\n// // - addItem(newItem) - принимает новый товар newItem и добавляет его в массив товаров в свойстве items объекта который вызывает этот метод.\n// // - removeItem(itemToRemove) - принимает товар itemToRemove и удаляет его из массива товаров в свойстве items объекта который вызывает этот метод.\n// // Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// class Storage {\n//     constructor(items) {\n//         this.items = items;\n//     }\n\n//     getItems() {\n//         return this.items\n//     }\n\n//     addItem(newItem) {\n//         // // вариант №1\n//         // return this.items.splice(3, 0, newItem)\n\n//         // // вариант №2, индекс вычисляется\n//         // const lastIndex = this.items.length;\n//         // this.items.splice(lastIndex, 1, newItem);\n//         // return this.items;\n\n//         // решение в автопроверке\n//         this.items.push(newItem);\n//     }\n\n\n//     removeItem(itemToRemove) {\n//         // // вариант №1\n//         // return this.items.splice(1, 1)\n\n//         // // вариант №2, индекс вычисляется\n//         // const itemIndex = this.items.indexOf(itemToRemove);\n//         // this.items.splice(itemIndex, 1);\n//         // return this.items;\n            \n//         // решение в автопроверке\n//             this.items = this.items.filter((item) => item !== itemToRemove);\n//     }\n// };\n\n// const storage = new Storage([\"Nanitoids\", \"Prolonger\", \"Antigravitator\"]);\n// console.log(storage);\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Prolonger\", \"Antigravitator\"]\n// storage.addItem(\"Droid\");\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Prolonger\", \"Antigravitator\", \"Droid\"]\n// storage.removeItem(\"Prolonger\");\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Antigravitator\", \"Droid\"]\n\n\n// // autocheck-05-11/20\n// // Напиши класс StringBuilder, который принимает один параметр initialValue - произвольную строку, которая записывается на создаваемый объект в свойство value.\n// // Объяви следующие методы класса:\n// // - getValue() - возвращает текущее значение свойства value.\n// // - padEnd(str) - получает параметр str (строку) и добавляет её в конец значения свойства value объекта который вызывает этот метод.\n// // - padStart(str) - получает параметр str (строку) и добавляет её в начало значения свойства value объекта который вызывает этот метод.\n// // - padBoth(str) - получает параметр str (строку) и добавляет её в начало и в конец значения свойства value объекта который вызывает этот метод.\n// // Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// class StringBuilder {\n//     constructor(initialValue) {\n//         this.value = initialValue;\n//     }\n\n//     getValue() {\n//         return this.value;\n//     }\n//     padEnd(str) {\n//         this.value += str;\n//     }\n//     padStart(str) {\n//         this.value = str + this.value;\n//     }\n//     padBoth(str) {\n//         this.padStart(str);\n//         this.padEnd(str);\n//     }\n// }\n\n// const builder = new StringBuilder(\".\");\n// console.log(builder.getValue());            // \".\"\n// builder.padStart(\"^\");\n// console.log(builder.getValue());            // \"^.\"\n// builder.padEnd(\"^\");\n// console.log(builder.getValue());            // \"^.^\"\n// builder.padBoth(\"=\");\n// console.log(builder.getValue());            // \"=^.^=\"\n\n\n// // autocheck-05-12/20\n// // Выполни рефакторинг класса Car так, чтобы свойство brand было приватным и добавь два метода для публичного интерфейса, для чтения и изменения этого свойства.\n// // - getBrand() - возвращает значение приватного свойства brand.\n// // - changeBrand(newBrand) - изменяет значение приватного свойства brand на newBrand.\n\n// class Car {\n//     #brand;\n//     model;\n//     price;\n//     constructor({brand, model, price}) {\n//         this.#brand = brand;\n//         this.model = model;\n//         this.price = price;\n//     }\n//     getBrand() {\n//         return this.#brand;\n//     }\n//     changeBrand(newBrand) {\n//         this.#brand = newBrand;\n//     }\n// }\n// const car1 = new Car({\n//     brand: \"Audi\",\n//     model: \"Q3\",\n//     price: 36000\n// });\n// const car2 = new Car({\n//     brand: \"BMW\",\n//     model: \"X5\",\n//     price: 58900\n// });\n// const car3 = new Car({\n//     brand: \"Nissan\",\n//     model: \"Murano\",\n//     price: 31700\n// });\n// // возвращение значения приватного свойства brand\n// console.log(car1.getBrand());           // Audi\n// // замена приватного свойства brand\n// console.log(car1.changeBrand(\"Honda\"));\n// console.log(car1.getBrand());           // Honda\n// console.log(car1);                      // Car {model: 'Q3', price: 36000, #brand: 'Honda'}\n\n// // возвращение объектов\n// console.log(car2);                      // Car {model: 'X5', price: 58900, #brand: 'BMW'}\n// console.log(car3);                      // Car {model: 'Murano', price: 31700, #brand: 'Nissan'}\n\n\n// // autocheck-05-13/20\n// // Выполни рефакторинг класса Storage, сделав свойство items приватным.\n// // Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// class Storage {\n//     #items;\n\n//     constructor(items) {\n//         this.#items = items;\n//     }\n\n//     getItems() {\n//         return this.#items\n//     }\n\n//     addItem(newItem) {\n//         this.#items.push(newItem);\n//     }\n\n//     removeItem(itemToRemove) {\n//         this.#items = this.#items.filter((item) => item !== itemToRemove);\n//     }\n// };\n\n// const storage = new Storage([\"Nanitoids\", \"Prolonger\", \"Antigravitator\"]);\n// console.log(storage);            // Storage {#items: Array(3)}\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Prolonger\", \"Antigravitator\"]\n// storage.addItem(\"Droid\");\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Prolonger\", \"Antigravitator\", \"Droid\"]\n// storage.removeItem(\"Prolonger\");\n// console.log(storage.getItems()); // [\"Nanitoids\", \"Antigravitator\", \"Droid\"]\n\n\n// // autocheck-05-14/20\n// // Выполни рефакторинг класса StringBuilder, сделав свойство value приватным.\n// // Под комментарием мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// class StringBuilder {\n//     #value;\n\n//     constructor(initialValue) {\n//         this.#value = initialValue;\n//     }\n\n//     getValue() {\n//         return this.#value;\n//     }\n//     padEnd(str) {\n//         this.#value += str;\n//     }\n//     padStart(str) {\n//         this.#value = str + this.#value;\n//     }\n//     padBoth(str) {\n//         this.padStart(str);\n//         this.padEnd(str);\n//     }\n// }\n\n// const builder = new StringBuilder(\".\");\n// console.log(builder.getValue());            // \".\"\n// builder.padStart(\"^\");\n// console.log(builder.getValue());            // \"^.\"\n// builder.padEnd(\"^\");\n// console.log(builder.getValue());            // \"^.^\"\n// builder.padBoth(\"=\");\n// console.log(builder.getValue());            // \"=^.^=\"\n\n\n// // autocheck-05-15/20\n// // Выполни рефакторинг класса Car. Сделай свойства model и price приватными, также как #brand. Стандартизируй публичный интерфейс класса, заменив уже объявленные методы на геттеры и сеттеры brand, model и price для взаимодействия с приватными свойствами.\n\n// class Car {\n//     #brand;\n//     #model;\n//     #price;\n\n//     constructor({ brand, model, price }) {\n//         this.#brand = brand;\n//         this.#model = model;\n//         this.#price = price;\n//     }\n\n//     get brand() {\n//         return this.#brand;\n//     }\n\n//     set brand(newBrand) {\n//         this.#brand = newBrand;\n//     }\n\n//     get model() {\n//         return this.#model;\n//     }\n\n//     set model(newModel) {\n//         this.#model = newModel;\n//     }\n\n//     get price() {\n//         return this.#price;\n//     }\n\n//     set price(newPrice) {\n//         this.#price = newPrice;\n//     }\n// }\n// const car1 = new Car({\n//     brand: \"Audi\",\n//     model: \"Q3\",\n//     price: 36000\n// });\n// const car2 = new Car({\n//     brand: \"BMW\",\n//     model: \"X5\",\n//     price: 58900\n// });\n// const car3 = new Car({\n//     brand: \"Nissan\",\n//     model: \"Murano\",\n//     price: 31700\n// });\n\n// console.log(Car);\n// console.log(car1);                      // Car {#brand: 'Audi', #model: 'Q3', #price: 36000}\n// console.log(car2);                      // Car {#brand: 'BMW', #model: 'X5', #price: 58900}\n// console.log(car3);                      // Car {#brand: 'Nissan', #model: 'Murano', #price: 31700}\n\n\n// // autocheck-05-16/20\n// // Выполни рефакторинг класса Car. Добавь публичное статическое свойство MAX_PRICE со значением 50000 - максимально допустимая цена автомобиля.\n// // Добавь сеттеру price проверку передаваемого значения параметра newPrice. Если оно больше чем MAX_PRICE, сеттер ничего не делает, а если меньше или равно, то перезаписывает цену автомобиля.\n\n// class Car {\n//     static MAX_PRICE = 50000;\n\n//     #price;\n\n//     constructor({ price }) {\n//         this.#price = price;\n//     }\n\n//     get price() {\n//         return this.#price;\n//     }\n\n//     set price(newPrice) {\n//         if (newPrice <= Car.MAX_PRICE) this.#price = newPrice;\n//     }\n// }\n\n// const audi = new Car({ price: 35000 });\n// console.log(audi.price);                // 35000\n// audi.price = 49000;\n// console.log(audi.price);                // 49000\n// audi.price = 51000;\n// console.log(audi.price);                // 49000\n\n\n// // autocheck-05-17/20\n// // Добавь классу Car публичный статический метод checkPrice(price), принимающий цену автомобиля. Метод должен сравнить значения параметра price и приватного статического свойства MAX_PRICE.\n// // - Если цена автомобиля превышает максимальную, метод должен вернуть строку \"Error! Price exceeds the maximum\".\n// // - В противном случае метод должен вернуть строку \"Success! Price is within acceptable limits\".\n// // Под объявлением класса мы добавили инициализацию экземпляра и вызовы методов, чтобы показать как будет использоваться метод checkPrice(price).\n\n// class Car {\n//     static #MAX_PRICE = 50000;\n\n//     static checkPrice(price) {\n//         if (price <= Car.#MAX_PRICE) {\n//             return 'Success! Price is within acceptable limits';\n//         }\n//         return 'Error! Price exceeds the maximum';\n//     }\n\n//     constructor({ price }) {\n//         this.price = price;\n//     }\n// }\n// const audi = new Car({ price: 36000 });\n// const bmw = new Car({ price: 64000 });\n\n// console.log(Car.checkPrice(audi.price)); // \"Success! Price is within acceptable limits\"\n// console.log(Car.checkPrice(bmw.price)); // \"Error! Price exceeds the maximum\"\n\n\n// // autocheck-05-18/20\n// // В приложении нужен администратор с возможностью добавлять почты пользователей в чёрный список.\n// // - Объяви класс Admin, который наследует от класса User\n// // - Добавь классу Admin публичное статическое свойство AccessLevel (уровень доступа), значение которого это объект { BASIC: \"basic\", SUPERUSER: \"superuser\" }\n\n// class User {\n//     constructor(email) {\n//         this.email = email;\n//     }\n\n//     get email() {\n//         return this.email;\n//     }\n\n//     set email(newEmail) {\n//         this.email = newEmail;\n//     }\n// }\n\n// class Admin extends User {\n//     static AccessLevel = {\n//         BASIC: \"basic\",\n//         SUPERUSER: \"superuser\"\n//     }\n// }\n\n// console.log(Admin);\n// console.log(Admin.AccessLevel.BASIC);\n// console.log(Admin.AccessLevel.SUPERUSER);\n\n\n// // autocheck-05-19/20\n// // Добавь классу Admin метод constructor, который принимает один параметр - объект настроек с двумя свойствами email и accessLevel. Добавь классу Admin публичное свойство accessLevel, значение которого будет передаваться при вызове конструктора.\n// // Чтобы показать как будет использоваться класс Admin мы добавили инициализацию экземпляра под объявлением класса.\n\n// class User {\n//     email;\n\n//     constructor(email) {\n//         this.email = email;\n//     }\n\n//     get email() {\n//         return this.email;\n//     }\n\n//     set email(newEmail) {\n//         this.email = newEmail;\n//     }\n// }\n\n// class Admin extends User {\n\n//     static AccessLevel = {\n//         BASIC: \"basic\",\n//         SUPERUSER: \"superuser\",\n//     };\n\n//     constructor({ email, accessLevel }) {\n//         super(email);\n//         this.accessLevel = accessLevel;\n//     }\n// }\n\n// const mango = new Admin({\n//     email: \"mango@mail.com\",\n//     accessLevel: Admin.AccessLevel.SUPERUSER,\n// });\n\n// console.log(mango.email);               // \"mango@mail.com\"\n// console.log(mango.accessLevel);         // \"superuser\"\n\n\n// // autocheck-05-20/20\n// // Добавь классу Admin следующие свойства и методы.\n// // - Публичное свойство blacklistedEmails для хранения чёрного списка почтовых адресов пользователей. Значение по умолчанию это пустой массив.\n// // - Публичный метод blacklist(email) для добавления почты в чёрный список. Метод должен добавлять значение параметра email в массив хранящийся в свойстве blacklistedEmails.\n// // - Публичный метод isBlacklisted(email) для проверки почты в чёрном списке. Метод должен проверять наличие значения параметра email в массиве хранящемся в свойстве blacklistedEmails и возвращать true или false.\n// // После объявления класса мы добавили инициализацию экземпляра и вызовы методов в той последовательности, в которой твой код будут проверять тесты. Пожалуйста ничего там не меняй.\n\n// class User {\n//     email;\n\n//     constructor(email) {\n//         this.email = email;\n//     }\n\n//     get email() {\n//         return this.email;\n//     }\n\n//     set email(newEmail) {\n//         this.email = newEmail;\n//     }\n// }\n// class Admin extends User {\n\n//     static AccessLevel = {\n//         BASIC: \"basic\",\n//         SUPERUSER: \"superuser\",\n//     };\n\n//     constructor({ email, accessLevel }) {\n//         super(email);\n//         this.accessLevel = accessLevel;\n//     }\n\n//     blacklistedEmails = [];\n    \n//     blacklist(email) {\n//         this.blacklistedEmails.push(email);\n//     }\n\n//     isBlacklisted(email) {\n//         return this.blacklistedEmails.includes(email);\n//     }\n// }\n\n// const mango = new Admin({\n//     email: \"mango@mail.com\",\n//     accessLevel: Admin.AccessLevel.SUPERUSER,\n// });\n\n// console.log(mango.email);                    // \"mango@mail.com\"\n// console.log(mango.accessLevel);              // \"superuser\"\n\n// mango.blacklist(\"poly@mail.com\");\n// console.log(mango.blacklistedEmails);        // [\"poly@mail.com\"]\n// console.log(mango.isBlacklisted(\"mango@mail.com\"));      // false\n// console.log(mango.isBlacklisted(\"poly@mail.com\"));       // true\n"],"names":[],"version":3,"file":"index.ab461811.js.map"}