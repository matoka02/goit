{"mappings":"YAAA,aA6uBAA,QAAQC,IAFJ,uBAEaC,MADN,iBAKXF,QAAQC,IAFG,gCAEMC,MADN,+BAGX,IAEIC,EAFO,yBAEID,MADJ,WAEXF,QAAQC,IAAIE,EAAI,IAChBH,QAAQC,IAAIE,EAAI,IAEhB,IAEIC,EAFO,oBAEOF,MADP,0BAEXF,QAAQC,IAAIG,EAAO,IACnBJ,QAAQC,IAAIG,EAAO,IACnBJ,QAAQC,IAAIG,EAAO,IACnBJ,QAAQC,IAAIG,EAAO,IAEnB,IAEIC,EAFO,YAEKH,MADL,YAEXF,QAAQC,IAAII,GAEZ,IAAIC,EAAW,YAAYC,SAAQ,aACnCP,QAAQC,IAAIK,GACXN,QAAOC,IAAIK,EAAS,IACrBE,QAAUC,MAAMC,KAAKF,SACrBR,QAAQC,IAAIK,EAAS,IACrBN,QAAQC,IAAIK,EAAS,G","sources":["src/js/varia.js"],"sourcesContent":["'use strict';\n\n\n/*--- 1.1 Открытие окон и методы window ---*/\n\n// let newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n// newWin.document.write(\"Hello, world!\");\n\n// let newWindow = open('/', 'example', 'width=300,height=300')\n// newWindow.focus();\n// alert(newWindow.location.href); // (*) about:blank, загрузка ещё не началась\n// newWindow.onload = function() {\n//   let html = `<div style=\"font-size:30px\">Добро пожаловать!</div>`;\n//   newWindow.document.body.insertAdjacentHTML('afterbegin', html);\n// };\n\n// let newWindow = open('/', 'example', 'width=300,height=300');\n// newWindow.onload = function() {\n//   newWindow.close();\n//   alert(newWindow.closed); // true\n// };\n\n\n/*--- 1.2 Общение между окнами ---*/\n\n// let oldDoc = iframe.contentDocument;\n// iframe.onload = function () {\n//   let newDoc = iframe.contentDocument;\n//   // загруженный document - не тот, который был в iframe при создании изначально!\n//   console.log(oldDoc == newDoc); // false\n// };\n\n// let oldDoc = iframe.contentDocument;\n// // каждый 100 мс проверяем, не изменился ли документ\n// let timer = setInterval(() => {\n//   let newDoc = iframe.contentDocument;\n//   if (newDoc == oldDoc) return;\n//   console.log(\"New document is here!\");\n//   clearInterval(timer); // отключим setInterval, он нам больше не нужен\n// }, 100);\n\n// console.log(iframe.contentWindow == frames[0]);       // true\n// console.log(iframe.contentWindow == frames.win);       // true\n\n\n/*--- 2.1 ArrayBuffer, бинарные массивы ---*/\n\n// let buffer = new ArrayBuffer(16);\n// console.log(buffer.byteLength);                 // 16\n\n// let view=new Uint32Array(buffer);\n// console.log(Uint32Array.BYTES_PER_ELEMENT);     // 4\n// console.log(view.length);                       // 4\n// console.log(view.byteLength);                   // 16\n\n// view[0] = 123456;\n// for (const num of view) {\n//   console.log(num);\n// };\n\n// 2.1.1 Дан массив из типизированных массивов Uint8Array. Напишите функцию concat(arrays), которая объединяет эти массивы в один типизированный массив и возвращает его.\n\n// function concat(arrays) {\n//   // находим общую длину переданных массивов\n//   let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n\n//   let result = new Uint8Array(totalLength);\n\n//   if (!arrays.length) return result;\n\n//   // копируем каждый из массивов в result\n//   // следующий массив копируется сразу после предыдущего\n//   let offset = 0;\n//   for(let array of arrays) {\n//     result.set(array, offset);\n//     offset += array.length;\n//   }\n\n//   return result;\n// };\n\n\n/*--- 2.4 File и FileReader ---*/\n\n// См. html\n\n\n/*--- 3.1 Fetch ---*/\n\n// 3.1.1 Создайте асинхронную функцию getUsers(names), которая получает на вход массив логинов пользователей GitHub, запрашивает у GitHub информацию о них и возвращает массив объектов-пользователей.\n// Информация о пользователе GitHub с логином USERNAME доступна по ссылке: https://api.github.com/users/USERNAME.\n// В песочнице есть тестовый пример.\n// Важные детали:\n// - На каждого пользователя должен приходиться один запрос fetch.\n// - Запросы не должны ожидать завершения друг друга. Надо, чтобы данные приходили как можно быстрее.\n// - Если какой-то запрос завершается ошибкой или оказалось, что данных о запрашиваемом пользователе нет, то функция должна возвращать null в массиве результатов.\n\n// describe(\"getUsers\", function () {\n//   it(\"gets users from GitHub\", async function () {\n//     let users = await getUsers(['iliakan', 'remy', 'no.such.users']);\n//     assert.equal(users[0].login, 'iliakan');\n//     assert.equal(users[1].login, 'remy');\n//     assert.equal(users[2], null);\n//   });\n// });\n\n// async function getUsers(names) {\n//   let jobs = [];\n\n//   for (let name of names) {\n//     let job = fetch(`https://api.github.com/users/${name}`).then(\n//       successResponse => {\n//         if (successResponse.status != 200) {\n//           return null;\n//         } else {\n//           return successResponse.json();\n//         }\n//       },\n//       failResponse => {\n//         return null;\n//       }\n//     );\n//     jobs.push(job);\n//   }\n\n//   let results = await Promise.all(jobs);\n//   console.log(results);\n\n//   // (3) [{…}, {…}, null]\n//   // 0:{login: 'matoka02', id: 120492521, node_id: 'U_kgDOBy6R6Q', avatar_url: 'https://avatars.githubusercontent.com/u/120492521?v=4', gravatar_id: '', …}\n//   // 1:{login: 'tessaNAM', id: 142529764, node_id: 'U_kgDOCH7U5A', avatar_url: 'https://avatars.githubusercontent.com/u/142529764?v=4', gravatar_id: '', …}\n//   // 2:null\n//   // length:3\n//   // [[Prototype]]:Array(0)\n\n//   return results;\n// };\n\n\n/*--- 3.3 Fetch: ход загрузки ---*/\n\n// // Шаг 1: начинаем загрузку fetch, получаем поток для чтения\n// let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');\n// const reader = response.body.getReader();\n\n// // Шаг 2: получаем длину содержимого ответа\n// const contentLength = +response.headers.get('Content-Length');\n\n// // Шаг 3: считываем данные:\n// let receivedLength = 0; // количество байт, полученных на данный момент\n// let chunks = []; // массив полученных двоичных фрагментов (составляющих тело ответа)\n// while(true) {\n//   const {done, value} = await reader.read();\n//   if (done) break;\n//   chunks.push(value);\n//   receivedLength += value.length;\n//   console.log(`Получено ${receivedLength} из ${contentLength}`)\n// };\n\n// // Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array\n// let chunksAll = new Uint8Array(receivedLength); // (4.1)\n// let position = 0;\n// for(let chunk of chunks) {\n//   chunksAll.set(chunk, position); // (4.2)\n//   position += chunk.length;\n// };\n\n// // Шаг 5: декодируем Uint8Array обратно в строку\n// let result = new TextDecoder(\"utf-8\").decode(chunksAll);\n\n// // Готово!\n// let commits = JSON.parse(result);\n// console.log(commits[0].author.login);           // iliakan\n\n\n/*--- 3.5 Fetch: запросы на другие сайты ---*/\n\n// 3.5.1 Как вы, вероятно, знаете, существует HTTP-заголовок Referer, который обычно содержит адрес страницы, инициировавшей сетевой запрос.\n// Например, при запросе (fetch) http://google.com с http://javascript.info/some/url заголовки выглядят так:\n// Accept: */*\n// Accept-Charset: utf-8\n// Accept-Encoding: gzip,deflate,sdch\n// Connection: keep-alive\n// Host: google.com\n// Origin: http://javascript.info\n// Referer: http://javascript.info/some/url\n// Как вы можете видеть, присутствуют и Referer, и Origin.\n// Вопросы:\n// - Почему нужен Origin, если Referer содержит даже больше информации?\n// - Возможно ли отсутствие Referer или Origin, или это неправильно?\n\n\n/*--- 3.7 Объекты URL ---*/\n\n// let url1 = new URL('https://javascript.info/profile/admin');\n// let url2 = new URL('/profile/admin', 'https://javascript.info');\n// let url3 = new URL('tester', url1);\n// console.log(url1.protocol);       // https:\n// console.log(url1.host);           // javascript.info\n// console.log(url1.pathname);       // /profile/admin\n// console.log(url2);\n// console.log(url3);\n\n// let url = new URL('https://google.com/search');\n// url.searchParams.set('q', 'test me!'); // добавим параметр, содержащий пробел и !\n// console.log(url.href); // https://google.com/search?q=test+me%21\n// url.searchParams.set('tbs', 'qdr:y'); // параметр с двоеточием :\n// // параметры автоматически кодируются\n// console.log(url.href); // https://google.com/search?query=test+me%21&tbs=qdr%3Ay\n// // перебрать параметры (в исходном виде)\n// for(let [name, value] of url.searchParams) {\n//   console.log(`${name}=${value}`); // q=test me!, далее tbs=qdr:y\n// };\n\n\n/*--- 3.10 Длинные опросы ---*/\n\n// Примерный код клиентской функции subscribe, которая реализует длинные опросы:\n\n// async function subscribe() {\n//   let response = await fetch(\"/subscribe\");\n\n//   if (response.status == 502) {\n//     // Статус 502 - это таймаут соединения;\n//     // возможен, когда соединение ожидало слишком долго\n//     // и сервер (или промежуточный прокси) закрыл его\n//     // давайте восстановим связь\n//     await subscribe();\n//   } else if (response.status != 200) {\n//     // Какая-то ошибка, покажем её\n//     showMessage(response.statusText);\n//     // Подключимся снова через секунду.\n//     await new Promise(resolve => setTimeout(resolve, 1000));\n//     await subscribe();\n//   } else {\n//     // Получим и покажем сообщение\n//     let message = await response.text();\n//     showMessage(message);\n//     // И снова вызовем subscribe() для получения следующего сообщения\n//     await subscribe();\n//   }\n// };\n\n// subscribe();\n\n\n/*--- 3.11 WebSocket ---*/\n\n// let socket = new WebSocket(\"wss://javascript.info/article/websocket/demo/hello\");\n\n// socket.onopen = function(e) {\n//   console.log(\"[open] Соединение установлено\");\n//   console.log(\"Отправляем данные на сервер\");\n//   socket.send(\"Меня зовут Тесса\");\n// };\n\n// socket.onmessage = function(evt) {\n//   console.log(`[message] Данные получены с сервера: ${evt.data}`);\n// };\n\n// socket.onclose = function(evt) {\n//   if (evt.wasClean) {\n//     console.log(`[close] Соединение закрыто чисто, код=${evt.code} причина=${evt.reason}`);\n//   } else {\n//     // например, сервер убил процесс или сеть недоступна\n//     // обычно в этом случае event.code 1006\n//     console.log('[close] Соединение прервано');\n//   }\n// };\n\n// socket.onerror = function(error) {\n//   console.log(`[error]`);\n// };\n\n\n/*--- 4.1 Куки, document.cookie ---*/\n\n// function getCookie(name) {\n//   let matches = document.cookie.match(new RegExp(\n//     \"(?:^|; )\" + name.replace(/([.$?*|{}()[\\]\\\\/+^])/g, '\\\\$1') + \"=([^;]*)\"\n//   ));\n//   return matches ? decodeURIComponent(matches[1]) : undefined;\n// };\n\n// function setCookie(name, value, options = {}) {\n\n//   options = {\n//     path: '/',\n//     // при необходимости добавьте другие значения по умолчанию\n//     ...options\n//   };\n\n//   if (options.expires instanceof Date) {\n//     options.expires = options.expires.toUTCString();\n//   };\n\n//   let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n//   for (let optionKey in options) {\n//     updatedCookie += \"; \" + optionKey;\n//     let optionValue = options[optionKey];\n//     if (optionValue !== true) {\n//       updatedCookie += \"=\" + optionValue;\n//     }\n//   };\n\n//   document.cookie = updatedCookie;\n// };\n\n\n// function deleteCookie(name) {\n//   setCookie(name, \"\", {\n//     'max-age': -1\n//   })\n// };\n\n\n/*--- 4.2 LocalStorage, sessionStorage ---*/\n\n// localStorage.setItem('test', 1);\n// console.log(localStorage.getItem('test'));      // 1\n// console.log(localStorage);                      // Storage {test: '1', loglevel: 'INFO', length: 2}\n// delete localStorage.test;\n// console.log(localStorage);                      // Storage {loglevel: 'INFO', length: 1}\n\n// // перебор ключей\n// for(let i=0; i<localStorage.length; i++) {\n//   let key = localStorage.key(i);\n//   console.log(`${key}: ${localStorage.getItem(key)}`);\n// };\n\n// for(let key in localStorage) {\n//   console.log(key); // покажет getItem, setItem и другие встроенные свойства\n// };\n\n// for(let key in localStorage) {\n//   if (!localStorage.hasOwnProperty(key)) {\n//     continue; // пропустит такие ключи, как \"setItem\", \"getItem\" и так далее\n//   }\n//   console.log(`${key}: ${localStorage.getItem(key)}`);\n// };\n\n// let keys = Object.keys(localStorage);\n// for(let key of keys) {\n//   console.log(`${key}: ${localStorage.getItem(key)}`);\n// };\n\n// 4.2.1 Создайте поле textarea, значение которого будет автоматически сохраняться при каждом его изменении.\n// Когда пользователь закроет страницу и потом откроет её заново он должен увидеть последнее введённое значение.\n\n// 1-й вариант \n// area.value = localStorage.getItem('area');\n// area.oninput = () => {\n//   localStorage.setItem('area', area.value)\n// };\n\n// 2-й вариант \n// let area = document.getElementById('area');\n// let areaText = localStorage.getItem('areaText');\n// area.value = (areaText) ? areaText : '';\n\n// function saveElemText(elem) {\n//   if (elem.value) localStorage.setItem(elem.id + 'Text', elem.value)\n//   else localStorage.removeItem(elem.id + 'Text');\n// };\n\n// let saveTimer = null;\n\n// area.oninput = function () {\n//   clearTimeout(saveTimer);\n//   // Сохранить, если перерыв после последнего ввода был более 1250 мс\n//   saveTimer = setTimeout(saveElemText, 1250, this);\n// };\n\n// // Сохранить при закрытии браузера/страницы\n// // (таймер перерыва может не успеть сработать)\n// window.onunload = () => saveElemText(area);\n\n\n/*--- 5.2 CSS-анимации ---*/\n\n// 5.2.1 Реализуйте анимацию, как в примере ниже (клик на самолёт):\n// - При нажатии картинка изменяет размеры с 40x24px до 400x240px (увеличивается в 10 раз).\n// - Время анимации 3 секунды.\n// - По окончании анимации вывести сообщение: «Анимация закончилась!».\n// - Если во время анимации будут дополнительные клики по картинке - они не должны ничего «сломать».\n\n// let ended = false;\n\n// flyjet.onclick = function () {\n//   flyjet.addEventListener('transitionend', function () {\n//     if (!ended) {\n//       ended = true;\n//       alert('Анимация закончилась!');\n//     }\n//   });\n//   flyjet.classList.add('growing');\n// };\n\n// 5.2.2 Модифицируйте решение предыдущей задачи Анимировать самолёт (CSS) , чтобы в процессе анимации изображение выросло больше своего стандартного размера 400x240px («выпрыгнуло»), а затем вернулось к нему.\n// Должно получиться, как в примере ниже (клик на самолёт):\n// В качестве исходного кода возьмите решение прошлой задачи.\n\n// flyjet.onclick = function() {\n//   flyjet.classList.add('growing');\n// };\n\n// 5.2.3 Напишите функцию showCircle(cx, cy, radius), которая будет рисовать постепенно растущий круг.\n// - cx,cy - координаты центра круга относительно окна браузера,\n// - radius - радиус круга.\n// Нажмите на кнопку ниже, чтобы увидеть как это должно выглядеть:\n// В исходном коде уже указаны правильные CSS-стили круга, таким образам задача заключается в том, чтобы сделать правильную анимацию.\n\n// см. html\n\n// 5.2.4 В задаче Анимированный круг показывается анимированный растущий круг.\n// Теперь предположим, что нам нужен не просто круг, а чтобы в нём было ещё и сообщение. Сообщение должно появиться после завершения анимации (круг полностью вырос), в противном случае это будет выглядеть некрасиво.\n// В решении задачи функция showCircle(cx, cy, radius) рисует окружность, но не даёт возможности отследить, когда она будет готова.\n// В аргументы добавьте колбэк: showCircle(cx, cy, radius, callback) который будет вызываться по завершении анимации. Колбэк в качестве аргумента должен получить круг <div>.\n// Вот пример:\n// showCircle(150, 150, 100, div => {\n//   div.classList.add('message-ball');\n//   div.append(\"Hello, world!\");\n// });\n// За основу возьмите решение задачи Анимированный круг.\n\n// см. html\n\n\n/*--- 5.3 JavaScript-анимации ---*/\n\n// 5.3.1 Создайте прыгающий мячик. Кликните, чтобы посмотреть, как это должно выглядеть:\n\n// function makeEaseOut(timing) {\n//   return function (timeFraction) {\n//     return 1 - timing(1 - timeFraction);\n//   }\n// };\n\n// function bounce(timeFraction) {\n//   for (let a = 0, b = 1; 1; a += b, b /= 2) {\n//     if (timeFraction >= (7 - 4 * a) / 11) {\n//       return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n//     }\n//   }\n// };\n\n// ball.onclick = function () {\n//   let to = field.clientHeight - ball.clientHeight;\n//   animate({\n//     duration: 2000,\n//     timing: makeEaseOut(bounce),\n//     draw(p//   for (let a = 0, b = 1; 1; a += b, b /= 2) {\n//     if (timeFraction >= (7 - 4 * a) / 11) {\n//       return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n//     }\n//   }\n// };\n\n// function quad(timeFraction) {\n//   return Math.pow(timeFraction, 2);\n// };\n\n// ball.onclick = function() {\n//   let height = field.clientHeight - ball.clientHeight;\n//   let width = 100;\n//   // анимация top (прыжки)\n//   animate({\n//     duration: 2000,\n//     timing: makeEaseOut(bounce),\n//     draw: function(progress) {\n//       ball.style.top = height * progress + 'px'\n//     }\n//   });\n//   // анимация left (движение вправо)\n//   animate({\n//     duration: 2000,\n//     timing: makeEaseOut(quad),\n//     draw: function(progress) {\n//       ball.style.left = width * progress + \"px\"\n//     }\n//   });\n// };rogress) {\n//       ball.style.top = to * progress + 'px'\n//     }\n//   });\n// };\n\n// 5.3.2 Сделайте отскок мяча вправо. Как в примере:\n// Напишите код для анимации. Расстояние слева 100px.\n// Возьмите решение предыдущей задачи Анимируйте прыгающий мячик за основу.\n\n// function makeEaseOut(timing) {\n//   return function(timeFraction) {\n//     return 1 - timing(1 - timeFraction);\n//   }\n// };\n\n// function bounce(timeFraction) {\n\n\n/*--- 6.2 Пользовательские элементы (Custom Elements) ---*/\n\n// 6.2.1 У нас уже есть элемент <time-formatted>, показывающий красиво отформатированное время.\n// Создайте элемент <live-timer>, показывающий текущее время:\n// - Внутри он должен использовать <time-formatted>, не дублировать его функциональность.\n// - Должен тикать (обновляться) каждую секунду.\n// - На каждом тике должно генерироваться пользовательское событие с именем tick, содержащее текущую дату в event.detail (смотрите главу Генерация пользовательских событий).\n// Использование:\n// <live-timer id=\"elem\"></live-timer>\n// <script>\n//   elem.addEventListener('tick', event => console.log(event.detail));\n// </script>\n\n// Пожалуйста, обратите внимание:\n// (1) Мы останавливаем таймер setInterval, когда элемент удаляется из документа. Это важно, иначе он продолжит тикать, даже если больше не нужен. И браузер не сможет очистить память от этого элемента.\n// (2) Мы можем получить доступ к текущей дате через свойство elem.date. Все методы и свойства класса, естественно, являются методами и свойствами элемента.\n// См. html\n\n\n/*--- 7.1 Введение: шаблоны и флаги ---*/\n\n// let str = \"Любо, братцы, любо!\";\n// console.log(str.match(/любо/gi));       // ['Любо', 'любо']\n// let result = str.match(/любо/i);\n// console.log(result[0]);                 // Любо\n// console.log(result.length);             // 1\n// console.log(result.index);              // 0\n// console.log(result.input);              // Любо, братцы, любо!\n\n// let matches = \"JavaScript\".match(/HTML/) || [];\n// if (!matches.length) {\n//   console.log(\"Совпадений нет\");        // Совпадений нет\n// };\n\n// console.log('We will, we will'.replace(/we/i, 'I'));    // I will, we will\n// console.log('We will, we will'.replace(/we/ig, 'I'));   // I will, I will\n// console.log('Люблю HTML'.replace(/HTML/, '$& и JavaScript'));   // Люблю HTML и JavaScript\n\n// let str = 'Я ЛюБлЮ JavaScript';\n// let regexp = /люблю/i;\n// console.log(regexp.test(str));        // true\n\n\n/*--- 7.2 Символьные классы ---*/\n\n// let str = \"+7(903)-123-45-67\";\n// let regexp = /\\d/g;\n// console.log(str.match(regexp));             // ['7', '9', '0', '3', '1', '2', '3', '4', '5', '6', '7']\n// console.log(str.match(regexp).join(''));    // 79031234567\n// console.log(str.replace(/\\D/g, ''));        // 79031234567\n\n// console.log('A\\nB'.match(/A.B/));           // null\n// console.log('A\\nB'.match(/A.B/s));          // ['A\\nB', index: 0, input: 'A\\nB', groups: undefined]\n\n// console.log('1 - 5'.match(/\\d-\\d/));        // null\n// console.log('1 - 5'.match(/\\d - \\d/));      // ['1 - 5', index: 0, input: '1 - 5', groups: undefined]\n// console.log('1 - 5'.match(/\\d\\s-\\s\\d/));    // ['1 - 5', index: 0, input: '1 - 5', groups: undefined]\n\n\n/*--- 7.3 Юникод: флаг \"u\" и класс \\p{...} ---*/\n\n// let str = 'A ბ ㄱ';\n// console.log(str.match(/\\p{L}/g));             // null\n// console.log(str.match(/\\p{L}/gu));            // ['A', 'ბ', 'ㄱ']\n\n\n/*--- 7.4 Якоря: начало строки ^ и конец $ ---*/\n\n// let str1 = 'Mary had a little lamb';\n// console.log(/^Mary/.test(str1));                // true\n// console.log(/lamb$/.test(str1));                // true\n\n// let goodInput = '12:34';\n// let badInput = '12:345';\n// let regexp = /^\\d\\d:\\d\\d$/;\n// console.log(regexp.test(goodInput));            // true\n// console.log(regexp.test(badInput));             // false\n\n// 7.4.1 Какая строка подойдёт под шаблон ^$?\n\n// let newString = '';\n// console.log(/^/.test(newString));\n// console.log(/$/.test(newString));\n\n\n/*--- 7.5 Многострочный режим якорей ^ $, флаг \"m\" ---*/\n\n// let str = `1е место: Винни\n// 2е место: Пятачок\n// 3е место: Слонопотам`;\n// console.log(str.match(/^\\d/gm));              // ['1', '2', '3']\n\n// let str2 = `Винни: 1\n// Пятачок: 2\n// Слонопотам: 3`;\n// console.log(str2.match(/\\d$/gm));             // ['1', '2', '3']\n// console.log(str2.match(/\\d\\n/g));             // ['1\\n', '2\\n']\n\n\n/*--- 7.6 Граница слова: \\b ---*/\n\n// let str = 'Hello, Java!';\n// console.log(str.match(/\\bHello\\b/));             // varia.js:603 ['Hello', index: 0, input: 'Hello, Java!', groups: undefined]\n// console.log(str.match(/\\bJava\\b/));              // ['Java', index: 7, input: 'Hello, Java!', groups: undefined]\n// console.log(str.match(/\\bHell\\b/));              // null\n// console.log(str.match(/\\bJava!\\b/));             // null\n\n// 7.6.1 Время имеет формат: часы:минуты. И часы, и минуты имеют две цифры, например, 09:00.\n// Введите регулярное выражение, чтобы найти время в строке: Завтрак в 09:00 в комнате 123:456.\n// P.S. В этой задаче пока нет необходимости проверять правильность времени, поэтому 25:99 также может быть верным результатом.\n// P.P.S. Регулярное выражение не должно находить 123:456.\n\n// let str = 'Завтрак в 09:00 в комнате 123:456.';\n// console.log(str.match(/\\b\\d\\d:\\d\\d\\b/));\n\n\n/*--- 7.7 Экранирование, специальные символы ---*/\n\n// let regexp = new RegExp('\\d\\.\\d');\n// console.log('Глава 5.1'.match(regexp));           // null\n\n// let regStr = '\\\\d\\\\.\\\\d';\n// console.log(regStr);                              // \\d\\.\\d\n// let regexp2 = new RegExp(regStr);\n// console.log('Глава 5.1'.match(regexp2));          // ['5.1', index: 6, input: 'Глава 5.1', groups: undefined]\n\n\n/*--- 7.8 Наборы и диапазоны [...] ---*/\n\n// console.log('Exception 0xAF'.match(/x[0-9A-F][0-9A-F]/g));    // ['xAF']\n\n// let regexp = /[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]/gu;\n// let str = `Hi 你好 12`;\n// console.log(str.match(regexp));                               // ['H', 'i', '你', '好', '1', '2']\n\n// console.log('alice15@gmail.com'.match(/[^\\d\\sA-Z]/gi));       // ['@', '.']\n\n// 7.8.1 У нас есть регулярное выражение /Java[^script]/.\n// Найдёт ли оно что-нибудь в строке Java? А в строке JavaScript?\n\n// console.log('Java'.match(/Java[^script]/));         // null\n// console.log('JavaScript'.match(/Java[^script]/));   // ['JavaS', index: 0, input: 'JavaScript', groups: undefined]\n\n// 7.8.2 Время может быть в формате часы:минуты или часы-минуты. И часы, и минуты имеют две цифры: 09:00 или 21-30.\n// Напишите регулярное выражение, чтобы найти время:\n// let regexp = /your regexp/g;\n// alert( \"Завтрак в 09:00. Ужин в 21-30\".match(regexp) ); // 09:00, 21-30\n// P.S. В этой задаче мы предполагаем, что время всегда правильное, нет необходимости отфильтровывать плохие строки, такие как «45:67». Позже мы разберёмся с этим.\n\n// let str = 'Завтрак в 09:00. Ужин в 21-30';\n// let regexp = /\\d\\d[-:]\\d\\d/g;\n// console.log(str.match(regexp));                       // ['09:00', '21-30']\n\n\n/*--- 7.9 Квантификаторы +, *, ? и {n} ---*/\n\n// let str = '+7(903)-123-45-67';\n// let numbers = str.match(/\\d{1,}/g);\n// console.log(numbers);                           // ['7', '903', '123', '45', '67']\n\n// let str1 = '+7(903)-123-45-67';\n// console.log(str1.match(/\\d+/g));                 // ['7', '903', '123', '45', '67']\n\n// let str2 = 'Следует писать color или colour?';\n// console.log(str2.match(/colou?r/g));            // ['color', 'colour']\n\n// let str3 = '100 10 1';\n// console.log(str3.match(/\\d0*/g));               // ['100', '10', '1']\n// console.log(str3.match(/\\d0+/g));               // ['100', '10']\n\n// // Регулярное выражение для десятичных дробей (чисел с плавающей точкой): \\d+\\.\\d+\n// let str4 = '0 1 12.345 7890';\n// console.log(str4.match(/\\d+\\.\\d+/g));           // ['12.345']\n\n// // Регулярное выражение для «открывающего HTML-тега без атрибутов», например, <span> или <p>.\n// let str5 = '<body> ... </body>';\n// console.log(str5.match(/<[a-z]+>/gi));          // ['<body>']\n// console.log(str5.match(/<[a-z][a-z0-9]*>/i));   // ['<body>', index: 0, input: '<body> ... </body>', groups: undefined]\n\n// // Регулярное выражение для «открывающего или закрывающего HTML-тега без атрибутов»: /<\\/?[a-z][a-z0-9]*>/i\n// let str6 = '<h1>Привет!</h1>';\n// console.log(str6.match(/<\\/?[a-z][a-z0-9]*>/gi));    // ['<h1>', '</h1>']\n\n// 7.8.1 Напишите регулярное выражение, которое ищет многоточие (3 и более точек подряд).\n// Проверьте его:\n\n// let str = 'Привет!... Как дела?.....';\n// let regexp = /\\.{3,}/g;\n// console.log(str.match(regexp));                   // ['...', '.....']\n\n// 7.8.2 Напишите регулярное выражение, которое ищет HTML-цвета в формате #ABCDEF: первым идёт символ #, и потом - 6 шестнадцатеричных символов.\n// Пример использования:\n// let regexp = /...ваше выражение.../\n// let str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678\";\n// alert( str.match(regexp) )  // #121212,#AA00ef\n// P.S. В рамках этого задания не нужно искать цвета, записанные в иных форматах типа #123 или rgb(1,2,3).\n\n// let str = 'color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2';\n// let regexp = /#[a-f0-9]{6}\\b/gi;\n// console.log(str.match(regexp));                   // ['#121212', '#AA00ef']\n\n\n/*--- 7.10 Жадные и ленивые квантификаторы ---*/\n\n// let str = 'a \"witch\" and her \"broom\" is one';\n// let regexp = /\".+\"/g;\n// console.log(str.match(regexp));                     // ['\"witch\" and her \"broom\"']\n// let regexp2 = /\".+?\"/g;\n// console.log(str.match(regexp2));                    // ['\"witch\"', '\"broom\"']\n// let regexp3 = /\"[^\"]+\"/g;\n// console.log(str.match(regexp3));                    // ['\"witch\"', '\"broom\"']\n\n// 7.10.1 Какое здесь будет совпадение?\n// \"123 456\".match(/\\d+? \\d+?/g) ); // ?\n\n// let str = '123 456';\n// let regexp = /\\d+? \\d+?/g;\n// console.log(str.match(regexp));                     // ['123 4']\n\n// 7.10.2 Найти все HTML-комментарии в тексте:\n// let regexp = /ваше регулярное выражение/g;\n// let str = `... <!-- My -- comment\n//  test --> ..  <!----> ..\n// `;\n// alert( str.match(regexp) ); // '<!-- My -- comment \\n test -->', '<!---->'\n\n// let regexp = /<!--.*?-->/gs;\n// let str = `... <!-- My -- comment \n//   test --> ..  <!----> ..\n// `;\n// console.log(str.match(regexp));             // ['\\x3C!-- My -- comment \\n  test -->', '\\x3C!---->']\n\n// 7.10.3 Создайте регулярное выражение, чтобы найти все (открывающие и закрывающие) HTML-теги с их атрибутами.\n// Пример использования:\n// let regexp = /ваше регулярное выражение/g;\n// let str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n// alert( str.match(regexp) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n// В этой задаче мы предполагаем, что теги выглядят как <...что угодно...>, и внутри тегов не может быть символов < и > (первый встреченный > закрывает тег).\n\n// let regexp = /<[^<>]+>/g;\n// let str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n// console.log(str.match(regexp));               // ['<a href=\"/\">', '<input type=\"radio\" checked>', '<b>']\n\n\n/*--- 7.11 Скобочные группы ---*/\n\nlet str1 = 'site.com my.site.com';\nlet regexp1 = /(\\w+\\.)+\\w+/g;\nconsole.log(str1.match(regexp1));             // ['site.com', 'my.site.com']\n\nlet str2 = 'my@mail.com @ his@site.com.uk';\nlet regexp2 = /[-.\\w]+@([\\w-]+\\.)+[\\w-]+/g;\nconsole.log(str2.match(regexp2));             // ['my@mail.com', 'his@site.com.uk']\n\nlet str3 = '<h1>Hello, world!</h1>';\nlet regexp3 = /<(.*?)>/;\nlet tag = str3.match(regexp3)\nconsole.log(tag[0]);                         // <h1>\nconsole.log(tag[1]);                         // h1\n\nlet str4 = '<span class=\"my\">';\nlet regexp4 = /<(([a-z]+)\\s*([^>]*))>/;\nlet result = str4.match(regexp4);\nconsole.log(result[0]);                         // <span class=\"my\">\nconsole.log(result[1]);                         // span class=\"my\"\nconsole.log(result[2]);                         // span\nconsole.log(result[3]);                         // class=\"my\"\n\nlet str5 = '<h1> <h2>';\nlet regexp5 = /<(.*?)>/g;\nlet tags = str5.match(regexp5)\nconsole.log(tags);                           // ['<h1>', '<h2>']\n    \nlet results1 = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\nconsole.log(results1);                        // RegExpStringIterator {}\nconsole.log(results1[0]);                     // undefined\nresults = Array.from(results);\nconsole.log(results1[0]);                     // ['<h1>', 'h1', index: 0, input: '<h1> <h2>', groups: undefined]\nconsole.log(results1[1]);                     // ['<h2>', 'h2', index: 5, input: '<h1> <h2>', groups: undefined]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//\n//\n// \n// 7.10 Жадные и ленивые квантификаторы\n// 7.11 Скобочные группы\n// 7.12 Обратные ссылки в шаблоне: \\N и \\k<имя>\n// 7.13 Альтернация (или) |\n// 7.14 Опережающие и ретроспективные проверки\n// 7.15 Катастрофический возврат\n// 7.16 Поиск на заданной позиции, флаг \"y\"\n// 7.17 Методы RegExp и String"],"names":["console","log","match","$c46c336cdbede36f$var$tag","$c46c336cdbede36f$var$result","$c46c336cdbede36f$var$tags","$c46c336cdbede36f$var$results1","matchAll","results","Array","from"],"version":3,"file":"varia.2198d588.js.map"}